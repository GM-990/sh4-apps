/******************************************************************************/
/* COPYRIGHT (C) 2009 STMicroelectronics - All Rights Reserved                */
/* ST makes no warranty express or implied including but not limited to,      */
/* any warranty of                                                            */
/*                                                                            */
/*   (i)  merchantability or fitness for a particular purpose and/or          */
/*   (ii) requirements, for a particular purpose in relation to the LICENSED  */
/*        MATERIALS, which is provided AS IS, WITH ALL FAULTS. ST does not    */
/*        represent or warrant that the LICENSED MATERIALS provided here      */
/*        under is free of infringement of any third party patents,           */
/*        copyrights, trade secrets or other intellectual property rights.    */
/*        ALL WARRANTIES, CONDITIONS OR OTHER TERMS IMPLIED BY LAW ARE        */
/*        EXCLUDED TO THE FULLEST EXTENT PERMITTED BY LAW                     */
/*                                                                            */
/******************************************************************************/

/**
   @file     stinject.h
   @brief    STINJECT driver header file
 */

/* Define to prevent recursive inclusion */
#ifndef _STINJECT_H_
#define _STINJECT_H_

/* C++ support ------------------------------------------------------------- */
#ifdef __cplusplus
extern "C" {
#endif

/* Includes ---------------------------------------------------------------- */
#include "stmmdefs.h"
#include "stddefs.h"
#include "stos.h"
#include "stpti.h"      /*
                         * included only for PTI4 builds where we need to pass a
                         * STPTI_StreamID_t value through the API. Far from ideal :(
                         */
#include "stbuffer.h"

/* Exported Constants ------------------------------------------------------ */
#define STINJECT_DRIVER_ID      (402)                        /* Unique driver identifier                   */
#define STINJECT_DRIVER_BASE    (STINJECT_DRIVER_ID << 16)   /* Driver base constant for event and errors  */

#ifndef STINJECT_MAX_BUFFER_PER_INJECTION
#define STINJECT_MAX_BUFFER_PER_INJECTION   (50)             /* Maximum number of noncontigious per one
                                                                STINJECT_InjectData call; this variable limit the number of FDMA
                                                                nodes per injection.*/
#endif
/* Exported Enums ---------------------------------------------------------- */

/* Error Code Definitions */
typedef enum STINJECT_Errors_e
{
    STINJECT_ERROR_NO_DESTINATION = STINJECT_DRIVER_BASE,  /* No destination is defined for the handle */
    STINJECT_ERROR_NO_SOURCE,                           /* No source is defined for the handle */
    STINJECT_ERROR_STBUFFER_MEMORY,                     /* Any error encountered during a memory operation from STBUFFER */
    STINJECT_ERROR_DMA_OPERATION,                       /* Error encountered during DMA operation. */
    STINJECT_ERROR_OPERATION_NOT_PERMITTED              /* Permission denied */
}STINJECT_Errors_t;

/* Destinations of injection */
typedef enum STINJECT_DestinationType_e
{
    STINJECT_DESTINATION_NONE = 0x00,                   /* No destination. Just consume data. */
    STINJECT_DESTINATION_BUFFER,                        /* Direct injection into buffer. */
    STINJECT_DESTINATION_FIFO,                          /* Indirect injection into a buffer via a HW FIFO (SWTS/PTI). */
    STINJECT_DESTINATION_FIFO_SHARED,                   /* Indirect injection into a buffer via a HW FIFO (SWTS/PTI) shared with other users */
    STINJECT_DESTINATION_FILE                           /* Injection into a file. */
} STINJECT_DestinationType_t;

/* Type of buffer */
typedef enum STINJECT_BufferType_e
{
    STINJECT_BUFFER_TYPE_STBUFFER = 0x00,               /* Using Buffer Id (Generated by STBUFFER) for INJECT interface */
    STINJECT_BUFFER_TYPE_EXTERNAL                       /* Its an external buffer allocaed by the user. Non-STBUFFER buffer */
}STINJECT_BufferType_t;

typedef enum STINJECT_BufferMapping_e
{
    STINJECT_USER_CONTIGUOUS = 0x00,                   /* To be used by default for OS2x. Under Linux, this means a physically
                                                           contiguous buffer in kernel space, mmaped into user space. */
    STINJECT_KERNEL_CONTIGUOUS,                        /* Only used under Linux - implies a physically contiguous kernel buffer */
    STINJECT_USER_FRAGMENTED,                          /* Only used under Linux - implies a malloc'ed buffer. */
    STINJECT_KERNEL_FRAGMENTED                         /* Only used under Linux - implies a physically fragmented kernel buffer.*/
} STINJECT_BufferMapping_t;

/* Type of Injection  */
typedef enum STINJECT_InjectionMethod_e
{
    STINJECT_METHOD_NULL = 0x00,                    /* Fake injection. Injection is not done, just for internal testing.   */
    STINJECT_METHOD_CPU,                            /* Injection done using CPU, via memcpy or register access to the FIFO */
    STINJECT_METHOD_DMA,                            /* Use embedded DMA of the chipset to push data to buffer or FIFO      */
    STINJECT_METHOD_CRYPTO,                         /* Use crypto DMA of the chipset to push data to buffer or FIFO        */
    STINJECT_METHOD_CUSTOM                          /* Use a complete custom injector implementation                       */
} STINJECT_InjectionMethod_t;


/* Exported Structures ---------------------------------------------------------- */
typedef U32 STINJECT_Handle_t;     /* Device handle */

/* Parameters of the Destination FIFO */
typedef struct STINJECT_DestinationFIFO_s
{
    U32                                BaseAddress;          /* Hardware FIFO physical base address for injection For 7200 it will be used as frontend handle */
    U32                                RequestSignal;        /* Hardware Request signal for DMA injection */
    U32                                StatusAddress;        /* Required for CPU injection, to read status of the FIFO */
    STBUFFER_ID_t                      DestinationBufferId;  /* Buffer ID of destination buffer (to be used for flow control).
                                                                Only used if DestinationType is FIFO. Discarded if flow control is OFF */
    U32                                PTI_Handle;           /* PTI5 injection */
} STINJECT_DestinationFIFO_t;


/* Parameters of the Destination FIFO when the SWTS is shared PTI4 only */

typedef struct STINJECT_DestinationFIFOShared_s
{
    ST_DeviceName_t                    PTI_DeviceName;       /* Mandatory for FIFO shared */
    STPTI_StreamID_t                   PTI_StreamID;
    STBUFFER_ID_t                      DestinationBufferId;  /* Buffer ID of destination buffer (to be used for flow control).
                                                                Only used if DestinationType is FIFO. Discarded if flow control is OFF */
} STINJECT_DestinationFIFOShared_t;

/* Callback for file-write operation when destination is file */
typedef void (*STINJECT_FileWriteMethod_t) (const void *FileHandle_p, const void *Buffer_p, const U32 Size);

/* Parameters of the Destination File  */
typedef struct STINJECT_DestinationFile_s
{
    void                                *FileHandle_p;      /* Handle to the file */
    U32                                 Attributes;         /* File attributes */
    STINJECT_FileWriteMethod_t          FileWrite_p;        /* Callback for file write */
} STINJECT_DestinationFile_t;


/* Data of buffer allocated by STBUFFER */
typedef struct STINJECT_STBUFFER_s
{
    STBUFFER_ID_t                    BufferId;            /* Buffer Id of buffer */
    U32                              InjectionSize;       /* Size of data to be injected for source buffer, available space
                                                             in destination buffer starting from offset */
    U32                              Offset;              /* Offset from base address (in bytes), to read from, for source or
                                                             to write from, for destination if flow control disabled */
} STINJECT_STBUFFER_t;


/* External Buffer data */
typedef struct STINJECT_ExternalBuffer_s
{
    U8                               *BufferBase_p;       /* Buffer Base Address */
    U32                              InjectionSize;       /* Size of data to be injected for source buffer, available space
                                                             in destination buffer starting from offset */
    U32                              Offset;              /* Offset from base address (in bytes), to read from for source or
                                                             to write from for destination */
} STINJECT_ExternalBuffer_t;

typedef struct STINJECT_DataBuffer_s
{
    U8                                  BufferCount;                /* Number of buffers in the array Buffer_p */
    STINJECT_BufferMapping_t            Mapping;                    /* Mapping of external buffer */
    STINJECT_BufferType_t               BufferType;                 /* Type of source buffer */
    union
    {
        STINJECT_ExternalBuffer_t           *ExtBuffer_p;           /* Array of external buffers */
        STINJECT_STBUFFER_t                 *STBuffer_p;            /* Array of buffers Allocated by STBUFFER */
    }Buffer;
} STINJECT_DataBuffer_t;



/* Details of Injection Parameters */
typedef struct STINJECT_InjectionParams_s
{
    /* Flow Control Params */
    BOOL                                EnableFlowControl;          /* Set to TRUE, to enable flow control.
                                                                       Only used if DestinationType is FIFO */
    U32                                 PayloadSize;                /* Size of data block (for example, TS packet) in the source buffer */
    U32                                 HeaderSize;                 /* Size of header */
    STINJECT_DataBuffer_t               SourceBuffer;               /* Source Buffer Data */
} STINJECT_InjectionParams_t;

/* Destination setup parameters */
typedef union STINJECT_DestinationParams_u
{
    STINJECT_DestinationFIFO_t          DestinationFIFO;       /* Required if destination is FIFO   */
    STINJECT_DestinationFIFOShared_t    DestinationFIFOShared; /* Required if destination is Shared FIFO (only used on PTI4)*/
    STINJECT_DataBuffer_t               DestinationBuffer;     /* Required if destination is BUFFER */
    STINJECT_DestinationFile_t          DestinationFile;       /* Required if destination is FILE   */


} STINJECT_DestinationParams_t;


/* Prototype of method to be passed by user for CUSTOM injection */
typedef void (*STINJECT_CustomMethod_t) (STINJECT_Handle_t Handle,  STINJECT_InjectionParams_t *InjectionParams_p,
                                                STINJECT_DestinationParams_t *Destination_p, STINJECT_DataBuffer_t* Source_p);

/* Initialization parameters - associate with a specific target */
typedef struct STINJECT_InitParams_s
{
    STBUFFER_Handle_t                   CacheMemory;       /* For allocating private data structures */
    STBUFFER_Handle_t                   NCacheMemory;      /* For allocating DMA nodes for injection */
    STINJECT_DestinationType_t          DestinationType;   /* FIFO / Buffer / File */
} STINJECT_InitParams_t;

/* Open parameters - associate with a specific method for injection into an initialised target */
typedef struct STINJECT_OpenParams_s
{
    /* Method of Injection */
    STINJECT_InjectionMethod_t           InjectionMethod;      /* CPU/ DMA/ CryptoDMA */
    /* Parameters depending on the selected method - none required for CPU, NULL, DMA */
    union
    {
        void*                            CryptoParams;        /* Parameters for a CRYPTO transfer. For example, this could be
                                                                 STTKDMA/ STCRYPT parameters depending on device? */
        STINJECT_CustomMethod_t          CustomMethod;        /* For CUSTOM injection */
    } MethodParams;
} STINJECT_OpenParams_t;


typedef struct STINJECT_TermParams_s
{
    BOOL                            ForceTerminate;        /* TRUE for forceful termination */
} STINJECT_TermParams_t;

typedef struct STINJECT_MarkerParams_s
{
    U16 PID;
    ST_MM_Bitstream_Marker_t Marker;
    U32 MarkerID0;
    U32 MarkerID1;
} STINJECT_MarkerParams_t;

/* Exported Variables ------------------------------------------------------ */

/* Exported Macros --------------------------------------------------------- */

/* Exported Functions ------------------------------------------------------ */

/* Get driver revision number */
ST_Revision_t   STINJECT_GetRevision (void);

/* Initialize an STINJECT device - associates with the destination target */
ST_ErrorCode_t  STINJECT_Init (const ST_DeviceName_t DeviceName, const STINJECT_InitParams_t *InitParams_p);
/* Terminates a initialized device */
ST_ErrorCode_t  STINJECT_Term ( const ST_DeviceName_t DeviceName, const STINJECT_TermParams_t *TermParams_p );

/* Open a device handle - associates with a method of injection into the initialised target */
ST_ErrorCode_t  STINJECT_Open (const ST_DeviceName_t DeviceName, const STINJECT_OpenParams_t *OpenParams_p,
                               STINJECT_Handle_t *Handle_p);
/* Closes an opened handle */
ST_ErrorCode_t  STINJECT_Close (STINJECT_Handle_t Handle);

/* Destination Setup - Setup the destination of injection */
ST_ErrorCode_t  STINJECT_SetupDestination(STINJECT_Handle_t Handle, const STINJECT_DestinationParams_t *DestinationParams_p);

/* Locks the target for the specified instance */
ST_ErrorCode_t  STINJECT_Lock (STINJECT_Handle_t Handle, S32 TimeOutMS);
/* Unlocks target already locked by the specified instance */
ST_ErrorCode_t  STINJECT_Unlock (STINJECT_Handle_t Handle);

/* Injects data to the destination specified by the device handle. This is a blocking call. */
/* Important:
   1)For injecting data with flow control enabled, there should be only one buffer in destination buffer list.
   Also destination buffer should be allocated/registered with STBUFFER and BufferId of Destination buffer must
   be provided to STINJECT.
*/
ST_ErrorCode_t  STINJECT_InjectData (STINJECT_Handle_t Handle,  STINJECT_InjectionParams_t *InjectionParams_p);

/*Consumer has to call for knowing current Write Ptr before consuming */
ST_ErrorCode_t STINJECT_BufferGetWritePointer (STINJECT_Handle_t Handle, void ** const Address_p);
/* Consumer has to update the current read pointer after data consumption  */
ST_ErrorCode_t STINJECT_BufferSetReadPointer (STINJECT_Handle_t Handle, void * const Address_p);

ST_ErrorCode_t STINJECT_BufferGetFreeLength (STINJECT_Handle_t Handle, BOOL EnableFlowControl, U32 *FreeLength);
ST_ErrorCode_t  STINJECT_BufferFlush(STINJECT_Handle_t Handle);
/* Export IPRC handler */
int stinject_IPrC_Handler(U32 request, void *arg);

/* fake packet insersion */
ST_ErrorCode_t STINJECT_InjectMarker(const STINJECT_Handle_t Handle, const U8 MarkerNumber, const STINJECT_MarkerParams_t * const MarkerParams_p);

/* C++ support ------------------------------------------------------------- */
#ifdef __cplusplus
}
#endif
#endif  /* _STINJECT_H_ */

/* End of stinject.h */



